#
fitCovGraph <- function(graph, S, N, start = NULL, ctrl = ctrlICF(),
                        regularize = FALSE, regHyperPar = NULL, scale = NULL )
{
  # The function implements the Iterative Conditional Fitting algorithm of
  # Chauduri et al. (2007) for estimating a (positive definite) covariance matrix
  # with zero entries, i.e. a covariance graph model
  #
  if ( any(diag(graph) != 0) ) stop ("You must provide an adjacency matrix with null diagonal")
  if ( !isSymmetric(graph) ) stop ("Adjacency matrix is not symmetric")

  V <- ncol(S)
  varnames <- colnames(S)
  S <- as.matrix(S)
  nPar <- sum(graph)/2

  if ( regularize ) {
    if ( is.null(regHyperPar) ) {
      omega <- V + 2
      S <- if ( V > N ) {
        ( diag(diag(S)) + S*N ) / (omega + N + V + 1)
        } else ( S + S*N ) / (omega + N + V + 1)
    } else {
      omega <- regHyperPar$omega
      scale <- regHyperPar$scale
      if ( !inherits(regHyperPar, "EM") ) S <- ( scale + S*N ) / (omega + N + V + 1)
      # if the function is not used in 'mixCovGraph' we compute the regularized S
      # if the function is used in 'mixCovGraph', regularized S is provided in input
    }
  } else {
    omega <- 0
    scale <- 0
  }

  if( min( eigen(S, only.values = TRUE)$val ) < sqrt(.Machine$double.eps) )
    stop("Covariance matrix is not positive definite")


  # the graph is complete ....................................................
  if ( nPar == choose(V, 2) )
  {
    sigma <- S
    dimnames(sigma) <- list(varnames, varnames)
    if ( regularize ) N <- N + omega + V + 1
    lk <- profileLogLik(sigma, S, N)
    return( list(sigma = sigma, loglik = lk, nPar = nPar + V,
                 df = choose(V, 2) - nPar, iter = 1) )
  }
  # the graph is fully disconnected ..........................................
  if ( sum(graph) == 0 )
  {
    sigma <- diag( diag(S) )
    dimnames(sigma) <- list(varnames, varnames)
    if ( regularize ) N <- N + omega + V + 1
    lk <- profileLogLik(sigma, S, N)
    return( list(sigma = sigma, loglik = lk, nPar = nPar + V,
                 df = choose(V, 2) - nPar, iter = 1) )
  }

  # get spouses and non spouses .............................................
  SP <- NS <- SP2 <- list()
  for ( i in 1:V ) {
    SP[[i]] <- which(graph[,i] == 1) - 1
    SP2[[i]] <- ifelse( SP[[i]] > i-1, SP[[i]] - 1, SP[[i]] )
    NS[[i]] <- setdiff(which(graph[,i] == 0), i) - 1
  }
  numSpo <- sapply(SP, length) != 0
  nonTrivial <- which( numSpo != 0 )
  noSpo <- which(numSpo == 0)

  # initialization ...........................................................
  if ( is.null(start) )
  {
    sigma <- diag( diag(S) )
    # sigma <- S      # better?
  } else {
    temp <- diag(start)
    start[graph == 0] <- 0
    diag(start) <- temp
    diag(start)[noSpo] <- diag(S)[noSpo]
    sigma <- as.matrix(start)
    if ( min( eigen(sigma)$values ) <= 0 ) sigma <- diag( diag(S) )
      # stop("Starting value is not feasible!")
    # sigma <- start
  }
  #...........................................................................

  # icf ......................................................................
  tol <- ctrl$tol
  maxIt <- ctrl$maxIt
  trace <- ctrl$trace

  out <- mixGGraph::icf( sigma, S, nonTrivial-1, SP, NS, SP2, 1:V-1, N, tol,
                         maxIt, trace, regularize, omega )

  sigma <- out$sigma
  dimnames(sigma) <- list(varnames, varnames)
  return( list(sigma = sigma, loglik = out$loglik, nPar = nPar + V,
               df = choose(V, 2) - nPar, iter = out$it) )
}
